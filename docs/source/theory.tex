Hypergraphs are a generalization of lattices for arbitrary dynamic
programming algorithms. In this section we define notation for
hypergraphs and show how they can be used to describe dynamic programming algorithms
and concise linear programs for decdoing problems.
Throughout this work we return to this formalism to easily move
between dynamic programming, hypergraph, and linear programming
representations.

\summary{Basic definitions for hypergraphs and CKY.}

\paragraph{Hypergraph}
A directed, ordered hypergraph is a pair $(\Ver, \Edges)$ where
$\Ver$ is a set of vertices, and $\Edges$ is a
set of directed hyperedges.  Each hyperedge $e \in \Edges$ is a tuple
$\HEdge{v_2 \ldots v_{|v|}}{v_1}$
where $v_i \in \Ver$ for $i \in \{1 \ldots |v|\}$. The {\em head} of the hyperedge is $h(e) = v_1$. The {\em tail} of the hypergraph is the  ordered sequence
$t(e) = \langle v_2 \ldots v_{|v|} \rangle$. The size of the tail $|t(e)|$ may vary
across different edges, but $|t(e)| \geq 1$ and $|t(e)| \leq k$ for
some small constant $k$ for all edges. We represent a directed graph as a directed hypergraph with $|t(e)| = 1$ for all
edges $e \in \Edges$.

Each vertex $v \in \Ver$ is either a {\em non-terminal} or a {\em terminal} in the hypergraph. 
The set of non-terminals is $\NonTerminals = \Set{v \in \Ver: h(e) = v \mathrm{\ for\ some\ }  e \in \Edges}$ .
Conversely, the set of terminals is defined as
$\Terminals = \Ver \setminus \NonTerminals$ .

All  hypergraphs used in this work are acyclic: informally
this implies that no hyperpath (as defined below) contains the same
vertex more than once (see \newcite{martin1990} for a full
definition).
\todo[inline]{maybe for the thesis this defn should be included}
Acyclicity implies a
partial topological ordering of the vertices. Let this partial
order be given by the inequality operator
$\TopLess$.   We also assume there is a
distinguished {\em root} vertex $\Root$ with the property that $\Root \TopLess v$ 
for all $v \in \Ver \setminus \Set{\Root}$. For hyperedges, we use $e \TopLess e'$ as shorthand for $h(e) \TopLess h(e')$.


% Because of acyclicity the vertices $\Ver$ form a partially ordered set (poset).
% Informally a vertex $v$ is earlier in the order of $w$ if there is some hyperpath from
% $v$ to $w$, which we write as $v \TopLess w$. If neither $v \TopLess w$ nor $w \TopLess v$
% the vertices are said to be incomparable. Within NLP, the operator $\TopLess$ is called the
% ``Inside'' relation, whereas vertices that are incomparable or $\TopGreat$ are called ``outside'' vertices.
% Define $\Inside{v} = \Set{w \in \Ver: v \TopLess w}$ and  $\Outside{v} = \Ver \setminus (\Inside{v} \cup \{v\})$



Define a hyperpath as a tuple $(x, y) \in \Bin{|\Ver|} \times \Bin{| \Edges |}$ 
where $x(v) =1$ if vertex $v$ is used in the
hyperpath, $x(v) = 0$ otherwise (similarly $y(e) = 1$ if hyperedge $e$ is
used in the hyperpath, $y(e)= 0$ otherwise).  A valid hypergraph
satisfies the following constraints:

\begin{itemize}

\item
The root vertex must be in the hyperpath, i.e.  $x(\Root) = 1$

\item For every vertex $v \in \NonTerminals$ visited in the hyperpath,
  $x(v) = 1$, there must be one hyperedge $e$ entering the vertex, $y(e) = 1$ 
  with $h(e) = v$. Conversely, for any vertex $v \in
  \NonTerminals$ not visited, $x(v) = 0$, any edge $e$ with $h(e) = v$
  must have $y(e) = 0$. We write this linear constraint as 

$\displaystyle x(v) = \sum_{e \in \Edges: h(e) = v} y(e)$ .
\todo[inline]{typo? x vs y? hmmm I see now you've introduced new variables but i think this is confusing as written}

\item For every visited vertex $v \in \Ver$ other than the root with
  $x(v) = 1$, there must be one leaving hyperedge, i.e. $e \in \Edges$
  with $y(e) = 1$ and with $v \in t(e)$ . Conversely, for every non-root
  vertex $v$ not visited, $x(v) = 0$ , no hyperedge $e\in \Edges$ with
  $y(e) = 1$ can have $v$ as one if its children,.  We write this
  constraints as , $\displaystyle x(v) = \sum_{e \in \Edges: v \in t(e)} y(e)$ for all $v \in \Ver \setminus \Set{\Root}$.
\end{itemize}


% Next we define a hyperpath as a tuple $(x, y) \in \Bin{|\Ver|} \times \Bin{| \Edges |}$ where $x(v) =1$ if
% vertex $v$ is used in the hyperpath, $x(v) = 0$ otherwise (similarly
% $y(e) = 1$ if edge $e$ is used in the hyperpath, $y(e)= 0$
% otherwise). The set of valid hyperpaths starting at the root is

We write the complete path  set as
\begin{eqnarray*}
  \PathSet = \{ (x, y) \in \PathSet : x(\Root) &=& 1, \\
  x(v) &=& \sum_{e \in \Edges: h(e) = v} y(e) \ \ \ \forall \ v \in \NonTerminals,  \\
  x(v) &=& \sum_{e \in \Edges : v \in t(e)} y(e)\ \ \ \forall \ v \in \Ver \setminus \Set{\Root} \}
\end{eqnarray*}


% We use $\PathSet$ to refer to the set of valid derivations. The set $\PathSet$ is a
% subset of $\{0, 1\}^{|\IndexSet|}$ (not all members of $\{0,
% 1\}^{|\IndexSet|}$ will correspond to valid derivations). Each derivation $y$ in the hypergraph will imply an ordered sequence of
% leaves $v_1 \ldots v_n$. We use $s(y)$ to refer to this sequence.

% In a weighted hypergraph problem, we assume a
% parameter vector $\Weights = \{\Weights_r : r \in \IndexSet\}$. The score for any
% derivation is
% $
% f(y) =  \WeightsT y = \sum_{r \in \IndexSet} \Weights_r y_r
% $.
% Simple bottom-up dynamic programming---essentially the CKY
% algorithm---can be used to find $y^* = \argmax_{y \in \PathSet} f(y)$
% under these definitions. In fact, if we define the ``size'' of a
% hypergraph with edges $\Edges$ to be
% \[
% |\Edges| = \sum_{e \in \Edges} k(e),
% \]
% then the dynamic programming algorithm runs in $O(|\Edges|)$ time.

The first problem we consider is {\em unconstrained} hypergraph search.
Let $\Weights \in \Reals^{|{\Edges}|}$  be the weight vector for the hypergraph.
The unconstrained search problem is to find
\[ \max_{(x,y) \in \PathSet} \sum_{e \in \Edges} \Weights(e) y(e) = \max_{(x,y) \in \PathSet} \Weights^\top y  \]


This maximization can be computed for any weight vector and directed
acyclic hypergraph in time $O(|\Edges|)$ (assuming $|t(e)|$ is bounded
by a constant for all edges) using simple bottom-up dynamic
programming---essentially the CKY algorithm.  Algorithm~\ref{fig:dp}
shows this algorithm.

For certain decoding problems it will be convenient to first define a GLM with derivation set $\Structs$ and high-level decoding problem, $\max_{y \in \Structs} \WeightsT y$. Then when discussing the details of decoding switch to a hypergraph representation where we express the same decoding problem as
$ \max_{(x,y) \in \PathSet} \WeightsT y$ with a one-to-one mapping between $\PathSet$ and $\Structs$. \todo[inline]{this para is brief, v hard to follow}


\begin{Algorithm}[h]{10cm}
\begin{algorithmic}
\Procedure{BestPathScore}{ }
\State{$\pi[v] \gets 0$ for all $v\in \Terminals$}
\For{$e \in \Edges$  in $\TopGreat$ order}
\State{$\HEdge{v_2 \ldots v_k}{v_1} \gets e$}
\State{$\displaystyle s \gets\Weights(e) + \sum_{i = 2}^k \pi[v_i]$ }
\If{$s > \pi[v_1]$} $\pi[v_1] \gets s$
\EndIf{}
\EndFor{}
\State{\Return{$\pi[\Root]$}}
\EndProcedure{}
\end{algorithmic}
\caption{Dynamic programming algorithm for unconstrained hypergraph search. Note that this version only returns the highest score: $\max_{(x,y) \in \PathSet} \Weights^\top y$. The optimal hyperpath can be found by including back-pointers.}
\label{fig:dp}
\end{Algorithm}


We can use this algorithm to decode constituency parses, dependency parses, and syntactic machine translation, as well as a generalization of the lattices used for speech alignment, part-of-speech tagging, and head-automata models for dependency parsing.

% For a vertex $a$, a \textit{partial hypergraph} is a hyperpath that satisfies a subset of the hyperpath constraints, of the form

% \begin{eqnarray}
%   x(a) = 1 \\
%   x(v) = \sum_{e : h(e) = v} y(e) \forall \ v \in \Ver \setminus \{a\} \\
%   x(v) = \sum_{e : v \in t(e)} y(e) \forall \ v \in \NonTerminals \\
% \end{eqnarray}
